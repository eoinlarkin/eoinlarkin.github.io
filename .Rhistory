# posterior: function for the posterior distribution
# z: function for the number of
z.o <- initial_z
lambda.o <- 1/initial_lambda
for(j in 1:(n-1)){
z <- Z(1)
lambda <- posterior(1, z)
z.o <- c(z.o, z)
lambda.o <- c(lambda.o, lambda)
}
return(cbind(z.o, lambda.o))
#return(as_tibble(iter = 1:n + 1,
#             z = z.o,
#            lambda = lambda.o))
}
samples <- gibbs_gen(n <- 10,
posterior = posterior,
Z = Z,
initial_z = ceiling(z_p * 18),
initial_lambda = lambda_prior)
View(samples)
gibbs_gen <- function(n, posterior, Z, initial_z, initial_lambda)
{
# z.0: initial value of z
# lambda.o: initial value of lambda
# n: number of simulations
# posterior: function for the posterior distribution
# z: function for the number of
z.o <- initial_z
lambda.o <- 1/initial_lambda
for(j in 2:n){
z <- Z(1)
lambda <- posterior(1, z)
z.o <- c(z.o, z)
lambda.o <- c(lambda.o, lambda)
}
return(cbind(z.o, lambda.o))
#return(as_tibble(iter = 1:n + 1,
#             z = z.o,
#            lambda = lambda.o))
}
samples <- gibbs_gen(n <- 10,
posterior = posterior,
Z = Z,
initial_z = ceiling(z_p * 18),
initial_lambda = lambda_prior)
View(samples)
gibbs_gen <- function(n, posterior, Z, initial_z, initial_lambda)
{
# z.0: initial value of z
# lambda.o: initial value of lambda
# n: number of simulations
# posterior: function for the posterior distribution
# z: function for the number of
z.o <- initial_z
lambda.o <- 1/initial_lambda
for(j in 2:n){
z <- Z(1)
lambda <- posterior(1, z)
z.o <- c(z.o, z)
lambda.o <- c(lambda.o, lambda)
}
out <- tibble(iter=1:n,
z = z.o,
lambda = lambda.o)
return(cbind(z.o, lambda.o))
#return(as_tibble(iter = 1:n + 1,
#             z = z.o,
#            lambda = lambda.o))
}
samples <- gibbs_gen(n <- 10,
posterior = posterior,
Z = Z,
initial_z = ceiling(z_p * 18),
initial_lambda = lambda_prior)
View(samples)
gibbs_gen <- function(n, posterior, Z, initial_z, initial_lambda)
{
# z.0: initial value of z
# lambda.o: initial value of lambda
# n: number of simulations
# posterior: function for the posterior distribution
# z: function for the number of
z.o <- initial_z
lambda.o <- 1/initial_lambda
for(j in 2:n){
z <- Z(1)
lambda <- posterior(1, z)
z.o <- c(z.o, z)
lambda.o <- c(lambda.o, lambda)
}
out <- tibble(iter=1:n,
z = z.o,
lambda = lambda.o)
return(out)
#return(cbind(z.o, lambda.o))
#return(as_tibble(iter = 1:n + 1,
#             z = z.o,
#            lambda = lambda.o))
}
samples <- gibbs_gen(n <- 10,
posterior = posterior,
Z = Z,
initial_z = ceiling(z_p * 18),
initial_lambda = lambda_prior)
View(samples)
knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)    # Required for plotting
library(gridExtra)  # Layout for ggplot
library(tibble)     # Coercing data into tibble for use in dataframe
metropolis.hastings <- function(f,                # the target distribution
g,                # the proposal distribution
random.g,         # a sample from the proposal distribution
x0,               # initial value for chain, in R it is x[1]
sigma,            # proposal st. dev.
chain.size){  # chain size
x <- c(x0, rep(NA,chain.size-1))                # initialize chain
counter <- 1                                    # new counter variable
for(i in 2:chain.size) {
y <- random.g(x[i-1],sigma)                     # generate Y from g(.|xt) using random.g
alpha <- min(1, f(y)*g(y,x[i-1],sigma)/(f(x[i-1])*g(x[i-1],y,sigma)))
if( runif(1)<alpha){
x[i] <- y
counter <- counter + 1                        # increasing counter by one
}
else
{
x[i] <- x[i-1]
}
}
return(list(output=x,   acceptance.rate = counter / chain.size ))
}
sigma=20
f <- function(x) dnorm(x,0,1)
random.g <- function(x,sigma) rnorm(1,x,sigma) # q(x,y)
g <- function(x,y,sigma) dnorm(y,x,sigma)
x0 <- 4
chain.size <- 1e4
x <- metropolis.hastings(f,g,random.g,x0,sigma,chain.size)$output
metropolis.hastings(f,g,random.g,x0,sigma,chain.size)$acceptance.rate
par(mfrow=c(1,2))
plot(x, xlab="x", ylab="f(x)", main=paste("Trace plot of x[t], sigma=", sigma),col="red", type="l")
xmin = min(x[(0.2*chain.size) : chain.size])
xmax = max(x[(0.2*chain.size) : chain.size])
xs.lower = min(-4,xmin)
xs.upper = max(4,xmax)
xs <- seq(xs.lower,xs.upper,len=1e3)
hist(x[(0.2*chain.size) : chain.size],50, xlim=c(xs.lower,xs.upper),col="blue",xlab="x", main="Metropolis-Hastings",freq=FALSE)
lines(xs,f(xs),col="red", lwd=1)
sigma=0.2
f <- function(x) dnorm(x,0,1)
random.g <- function(x,sigma) rnorm(1,x,sigma) # q(x,y)
g <- function(x,y,sigma) dnorm(y,x,sigma)
x0 <- 4
chain.size <- 1e4
x <- metropolis.hastings(f,g,random.g,x0,sigma,chain.size)$output
metropolis.hastings(f,g,random.g,x0,sigma,chain.size)$acceptance.rate
par(mfrow=c(1,2))
plot(x, xlab="x", ylab="f(x)", main=paste("Trace plot of x[t], sigma=", sigma),col="red", type="l")
xmin = min(x[(0.2*chain.size) : chain.size])
xmax = max(x[(0.2*chain.size) : chain.size])
xs.lower = min(-4,xmin)
xs.upper = max(4,xmax)
xs <- seq(xs.lower,xs.upper,len=1e3)
hist(x[(0.2*chain.size) : chain.size],50, xlim=c(xs.lower,xs.upper),col="blue",xlab="x", main="Metropolis-Hastings",freq=FALSE)
lines(xs,f(xs),col="red", lwd=1)
sigma=3
f <- function(x) dnorm(x,0,1)
random.g <- function(x,sigma) rnorm(1,x,sigma) # q(x,y)
g <- function(x,y,sigma) dnorm(y,x,sigma)
x0 <- 4
chain.size <- 1e4
x <- metropolis.hastings(f,g,random.g,x0,sigma,chain.size)$output
metropolis.hastings(f,g,random.g,x0,sigma,chain.size)$acceptance.rate
par(mfrow=c(1,2))
plot(x, xlab="x", ylab="f(x)", main=paste("Trace plot of x[t], sigma=", sigma),col="red", type="l")
xmin = min(x[(0.2*chain.size) : chain.size])
xmax = max(x[(0.2*chain.size) : chain.size])
xs.lower = min(-4,xmin)
xs.upper = max(4,xmax)
xs <- seq(xs.lower,xs.upper,len=1e3)
hist(x[(0.2*chain.size) : chain.size],50, xlim=c(xs.lower,xs.upper),col="blue",xlab="x", main="Metropolis-Hastings",freq=FALSE)
lines(xs,f(xs),col="red", lwd=1)
x[x>2]
x[]>2
data <- bvnorm(1000, c(0,0), c(1,1), 0.5)
install.packages('mvtnorm')
library(bvnorm)
source("http://jgscott.github.io/teaching/r/mvnorm/rbvnorm.R")
data <- bvnorm(1000, c(0,0), c(1,1), 0.5)
prob <- length(x[x > 2]) / length(x)
x_vals <- x[x > 2]
s <- sqrt(var(x_vals))
ci_upper <- prob + 1.96 * (s/sqrt(length(x)))
ci_lower <- prob - 1.96 * (s/sqrt(length(x)))
prob <- length(x[x > 2]) / length(x)
x_vals <- x[x > 2]
s <- sqrt(var(x_vals))
ci_upper <- prob + 1.96 * (s/sqrt(length(x)))
ci_lower <- prob - 1.96 * (s/sqrt(length(x)))
ci_interval <- c(ci_lower, ci_upper)
ci_interval
sigma_1 = 20
sigma_2 = 0.2
sigma_3 = 3
# Defining our functions
f <- function(x) dnorm(x,0,1)
random.g <- function(x,sigma) rnorm(1,x,sigma) # q(x,y)
g <- function(x,y,sigma) dnorm(y,x,sigma)
x0 <- 4
chain.size <- 1e4
x_samps_1 <- metropolis.hastings(f,g,random.g,x0,sigma_1,chain.size)
x_samps_2 <- metropolis.hastings(f,g,random.g,x0,sigma_2,chain.size)
x_samps_3 <- metropolis.hastings(f,g,random.g,x0,sigma_3,chain.size)
metropolis.hastings.beta <- function(x0,               # initial value for chain, in R it is x[1]
chain.size,
target.alpha,
target.beta){      # chain size
f <- function(x) dbeta(x,target.alpha,target.beta) # defining our target function
x <- c(x0, rep(NA,chain.size-1))                # initialize chain
counter <- 1
for(i in 2:chain.size) {
y <- runif(1)                     # generate Y from g(.|xt) using random.g
alpha <- min(1, f(y)*1 /(f(x[i-1])*1 )) # 1 as we are using a uniform proposal distribution
if( runif(1)<alpha){
x[i] <- y
counter <- counter + 1}
else
{x[i] <- x[i-1]}}
return(list(output=x,   acceptance.rate = counter / chain.size ))
}
x.output <- metropolis.hastings.beta(0.1, 1e4, 2.5, 4.5)
x.samps <- x.output$output
x.samps <- tibble(iter = 1:length(x.samps),
x.samps = x.samps)
plot1 <-  ggplot(x.samps, aes(x=iter, y=x.samps)) +
geom_line(color="red")
plot2 <-  ggplot(as.data.frame(x.samps), aes(x=x.samps)) +
geom_histogram(aes(y =..density..), binwidth=0.025, colour="black", fill="skyblue", alpha=0.25)+
geom_area(stat='function', fun=dbeta, args=list(shape1=2.5,shape2=4.5), color='darkred', fill='darkred', alpha=0.33) +
##scale_colour_manual("Legend", values = c("black", "darkred")) +
labs(title="Plot of Simulated (Blue) and Theoretical (Red) Distributions",
x = "X Values")
grid.arrange(plot1, plot2, ncol=2)
x.output$acceptance.rate
plot1 <-  ggplot(samples, aes(x=lambda)) +
geom_histogram(aes(y =..density..), binwidth=0.025, colour="black", fill="skyblue", alpha=0.25)+
labs(title="Histogram of Lambda")
plot2 <-  ggplot(samples, aes(x=z)) +
geom_histogram(aes(y =..density..), binwidth=0.025, colour="black", fill="skyblue", alpha=0.25)+
labs(title="Histogram of Z")
grid.arrange(plot1, plot2, ncol=2)
samples <- gibbs_gen(n <- 1e4,
posterior = posterior,
Z = Z,
initial_z = ceiling(z_p * 18),
initial_lambda = lambda_prior)
plot1 <-  ggplot(samples, aes(x=lambda)) +
geom_histogram(aes(y =..density..), binwidth=0.1, colour="black", fill="skyblue", alpha=0.25)+
labs(title="Histogram of Lambda")
plot2 <-  ggplot(samples, aes(x=z)) +
geom_histogram(aes(y =..density..), binwidth=1, colour="black", fill="skyblue", alpha=0.25)+
labs(title="Histogram of Z")
grid.arrange(plot1, plot2, ncol=2)
# Means and variances
lambda_mean <- mean(samples$lambda)
lambda_sd <- sd(samples$lambda)
z_mean <- mean(samples$z)
z_sd <- sd(samples$z)
z_sd
18* p_z * (1-p_z)
18* z_p * (1-z_p)
sqrt(18* z_p * (1-z_p))
x.output <- metropolis.hastings.beta(0.1, 1e4, 2.5, 4.5)
x.samps <- x.output$output
x.samps <- tibble(iter = 1:length(x.samps),
x.samps = x.samps)
plot1 <-  ggplot(x.samps, aes(x=iter, y=x.samps)) +
geom_line(color="red", alpha=-.25)
plot2 <-  ggplot(as.data.frame(x.samps), aes(x=x.samps)) +
geom_histogram(aes(y =..density..), binwidth=0.025, colour="black", fill="skyblue", alpha=0.25)+
geom_area(stat='function', fun=dbeta, args=list(shape1=2.5,shape2=4.5), color='darkred', fill='darkred', alpha=0.33) +
##scale_colour_manual("Legend", values = c("black", "darkred")) +
labs(title="Plot of Simulated (Blue) and Theoretical (Red) Distributions",
x = "X Values")
grid.arrange(plot1, plot2, ncol=2)
x.output <- metropolis.hastings.beta(0.1, 1e4, 2.5, 4.5)
x.samps <- x.output$output
x.samps <- tibble(iter = 1:length(x.samps),
x.samps = x.samps)
plot1 <-  ggplot(x.samps, aes(x=iter, y=x.samps)) +
geom_line(color="red", alpha=0.25)
plot2 <-  ggplot(as.data.frame(x.samps), aes(x=x.samps)) +
geom_histogram(aes(y =..density..), binwidth=0.025, colour="black", fill="skyblue", alpha=0.25)+
geom_area(stat='function', fun=dbeta, args=list(shape1=2.5,shape2=4.5), color='darkred', fill='darkred', alpha=0.33) +
##scale_colour_manual("Legend", values = c("black", "darkred")) +
labs(title="Plot of Simulated (Blue) and Theoretical (Red) Distributions",
x = "X Values")
grid.arrange(plot1, plot2, ncol=2)
x.output <- metropolis.hastings.beta(0.1, 1e4, 2.5, 4.5)
x.samps <- x.output$output
x.samps <- tibble(iter = 1:length(x.samps),
x.samps = x.samps)
plot1 <-  ggplot(x.samps, aes(x=iter, y=x.samps)) +
geom_line(color="red", alpha=0.5)
plot2 <-  ggplot(as.data.frame(x.samps), aes(x=x.samps)) +
geom_histogram(aes(y =..density..), binwidth=0.025, colour="black", fill="skyblue", alpha=0.25)+
geom_area(stat='function', fun=dbeta, args=list(shape1=2.5,shape2=4.5), color='darkgreen', fill='darkgreen', alpha=0.33) +
##scale_colour_manual("Legend", values = c("black", "darkred")) +
labs(title="Plot of Simulated (Blue) and Theoretical (Red) Distributions",
x = "X Values")
grid.arrange(plot1, plot2, ncol=2)
x.output <- metropolis.hastings.beta(0.1, 1e4, 2.5, 4.5)
x.samps <- x.output$output
x.samps <- tibble(iter = 1:length(x.samps),
x.samps = x.samps)
plot1 <-  ggplot(x.samps, aes(x=iter, y=x.samps)) +
geom_line(color="red", alpha=0.5)
plot2 <-  ggplot(as.data.frame(x.samps), aes(x=x.samps)) +
geom_histogram(aes(y =..density..), binwidth=0.025, colour="black", fill="skyblue", alpha=0.25)+
geom_area(stat='function', fun=dbeta, args=list(shape1=2.5,shape2=4.5), color='darkgreen', fill='darkgreen', alpha=0.15) +
##scale_colour_manual("Legend", values = c("black", "darkred")) +
labs(title="Plot of Simulated (Blue) and Theoretical (Red) Distributions",
x = "X Values")
grid.arrange(plot1, plot2, ncol=2)
x.output <- metropolis.hastings.beta(0.1, 1e4, 2.5, 4.5)
x.samps <- x.output$output
x.samps <- tibble(iter = 1:length(x.samps),
x.samps = x.samps)
plot1 <-  ggplot(x.samps, aes(x=iter, y=x.samps)) +
geom_line(color="red", alpha=0.5)
plot2 <-  ggplot(as.data.frame(x.samps), aes(x=x.samps)) +
geom_histogram(aes(y =..density..), binwidth=0.025, colour="black", fill="skyblue", alpha=0.25)+
geom_area(stat='function', fun=dbeta, args=list(shape1=2.5,shape2=4.5), color='darkyellow', fill='darkyellow', alpha=0.15) +
##scale_colour_manual("Legend", values = c("black", "darkred")) +
labs(title="Plot of Simulated (Blue) and Theoretical (Red) Distributions",
x = "X Values")
grid.arrange(plot1, plot2, ncol=2)
x.output <- metropolis.hastings.beta(0.1, 1e4, 2.5, 4.5)
x.samps <- x.output$output
x.samps <- tibble(iter = 1:length(x.samps),
x.samps = x.samps)
plot1 <-  ggplot(x.samps, aes(x=iter, y=x.samps)) +
geom_line(color="red", alpha=0.5)
plot2 <-  ggplot(as.data.frame(x.samps), aes(x=x.samps)) +
geom_histogram(aes(y =..density..), binwidth=0.025, colour="black", fill="skyblue", alpha=0.25)+
geom_area(stat='function', fun=dbeta, args=list(shape1=2.5,shape2=4.5), color='yellow', fill='yellow', alpha=0.15) +
##scale_colour_manual("Legend", values = c("black", "darkred")) +
labs(title="Plot of Simulated (Blue) and Theoretical (Red) Distributions",
x = "X Values")
grid.arrange(plot1, plot2, ncol=2)
plot1 <-  ggplot(samples, aes(x=lambda)) +
geom_histogram(aes(y =..density..), binwidth=0.1, colour="black", fill="skyblue", alpha=0.25)+
labs(title="Histogram of Lambda")
plot2 <-  ggplot(samples, aes(x=z)) +
geom_histogram(aes(y =..density..), binwidth=1, colour="black", fill="skyblue", alpha=0.25)+
labs(title="Histogram of Z")
grid.arrange(plot1, plot2, ncol=2)
# Trace plots
plot3 <-  ggplot(x.samps, aes(x=iter, y=lambda)) +
geom_line(color="red", alpha=0.5)
plot4 <-  ggplot(x.samps, aes(x=iter, y=z)) +
geom_line(color="red", alpha=0.5)
grid.arrange(plot3, plot4, ncol=2)
gibbs_gen <- function(n, posterior, Z, initial_z, initial_lambda)
{
# z.0: initial value of z
# lambda.o: initial value of lambda
# n: number of simulations
# posterior: function for the posterior distribution
# z: function for the number of
z.o <- initial_z
lambda.o <- 1/initial_lambda
for(j in 2:n){
z <- Z(1)
lambda <- posterior(1, z)
z.o <- c(z.o, z)
lambda.o <- c(lambda.o, lambda)
}
out <- tibble(iter=1:n,
z = z.o,
lambda = lambda.o)
return(out)
}
samples <- gibbs_gen(n <- 1e4,
posterior = posterior,
Z = Z,
initial_z = ceiling(z_p * 18),
initial_lambda = lambda_prior)
plot1 <-  ggplot(samples, aes(x=lambda)) +
geom_histogram(aes(y =..density..), binwidth=0.1, colour="black", fill="skyblue", alpha=0.25)+
labs(title="Histogram of Lambda")
plot2 <-  ggplot(samples, aes(x=z)) +
geom_histogram(aes(y =..density..), binwidth=1, colour="black", fill="skyblue", alpha=0.25)+
labs(title="Histogram of Z")
grid.arrange(plot1, plot2, ncol=2)
# Trace plots
plot3 <-  ggplot(x.samps, aes(x=iter, y=lambda)) +
geom_line(color="red", alpha=0.5)
plot4 <-  ggplot(x.samps, aes(x=iter, y=z)) +
geom_line(color="red", alpha=0.5)
grid.arrange(plot3, plot4, ncol=2)
plot1 <-  ggplot(samples, aes(x=lambda)) +
geom_histogram(aes(y =..density..), binwidth=0.1, colour="black", fill="skyblue", alpha=0.25)+
labs(title="Histogram of Lambda")
plot2 <-  ggplot(samples, aes(x=z)) +
geom_histogram(aes(y =..density..), binwidth=1, colour="black", fill="skyblue", alpha=0.25)+
labs(title="Histogram of Z")
grid.arrange(plot1, plot2, ncol=2)
# Trace plots
plot3 <-  ggplot(samples, aes(x=iter, y=lambda)) +
geom_line(color="red", alpha=0.5)
plot4 <-  ggplot(samples, aes(x=iter, y=z)) +
geom_line(color="red", alpha=0.5)
grid.arrange(plot3, plot4, ncol=2)
sum_output <- function(x){
prob <- length(x[x > 2]) / length(x)
x_vals <- x[x > 2]
s <- sqrt(var(x_vals))
ci_upper <- prob + 1.96 * (s/sqrt(length(x)))
ci_lower <- prob - 1.96 * (s/sqrt(length(x)))
ci_interval <- c(ci_lower, ci_upper)
out <- list(prob, s, ci_interval)
return(out)
}
x1_summary <- sum_output(x_samps_1$output)
x2_summary <- sum_output(x_samps_2$output)
x3_summary <- sum_output(x_samps_3$output)
# Defining our posterior:
z <- Z(1)
alpha = 1
beta = lambda_prior
sum_xi = function(z) {0*z + 1*(18-Z(1)) + 2*13 + 3*8 + 4*3 + 5*4 + 6*3 + 10*1}
m = 50
posterior <- function(n, z) rgamma(n=n, shape=alpha+sum_xi(z), rate=(beta+m))
gibbs_gen <- function(n, posterior, Z, initial_z, initial_lambda)
{
# z.0: initial value of z
# lambda.o: initial value of lambda
# n: number of simulations
# posterior: function for the posterior distribution
# z: function for the number of
z.o <- initial_z
lambda.o <- 1/initial_lambda
for(j in 2:n){
z <- Z(1)
lambda <- posterior(1, z)
z.o <- c(z.o, z)
lambda.o <- c(lambda.o, lambda)
}
out <- tibble(iter=1:n,
z = z.o,
lambda = lambda.o)
return(out)
}
--version
r --version
R --version
R.version()
R.Version()
devtools::install_github("marcusvolz/strava")
devtools::install_github("marcusvolz/strava")
devtools::install_github("marcusvolz/strava")
install.packages(c("backports", "broom", "cli", "ggplot2", "isoband", "jsonlite", "nimble", "pillar", "processx", "rlang", "rmarkdown", "testthat", "tinytex", "vctrs"))
install.packages(c("backports", "broom", "cli", "ggplot2", "isoband", "jsonlite", "nimble", "pillar", "processx", "rlang", "rmarkdown", "testthat", "tinytex", "vctrs"))
install.packages(c("backports", "broom", "cli", "ggplot2", "isoband", "jsonlite", "nimble", "pillar", "processx", "rlang", "rmarkdown", "testthat", "tinytex", "vctrs"))
install.packages(c("backports", "broom", "cli", "ggplot2", "isoband", "jsonlite", "nimble", "pillar", "processx", "rlang", "rmarkdown", "testthat", "tinytex", "vctrs"))
install.packages(c("backports", "broom", "cli", "ggplot2", "isoband", "jsonlite", "nimble", "pillar", "processx", "rlang", "rmarkdown", "testthat", "tinytex", "vctrs"))
install.packages("rlang")
install.packages("rlang")
install.packages("rlang")
install.packages('blogdown')
blogdown::install_hugo()
blogdown:::insert_image_addin()
blogdown:::insert_image_addin()
blogdown::build_site()
setwd("C:/Users/Eoin/OneDrive/Data Science/Github/eoinlarkin.github.io")
blogdown::build_site()
blogdown::serve_site()
blogdown::hugo_build()
blogdown::build_site()
blogdown::stop_server()
blogdown::build_site()
blogdown::serve_site()
blogdown:::insert_image_addin()
blogdown:::insert_image_addin()
blogdown::build_site()
blogdown::serve_site()
blogdown::stop_server()
blogdown::hugo_build()
blogdown::build_site()
blogdown:::update_meta_addin()
blogdown:::insert_image_addin()
blogdown:::preview_site(startup = TRUE)
blogdown:::insert_image_addin()
blogdown::build_site()
blogdown::hugo_build()
blogdown::stop_server()
blogdown::serve_site()
blogdown::stop_server()
blogdown::hugo_build()
blogdown::serve_site()
blogdown::stop_server()
blogdown::hugo_build()
blogdown::serve_site()
blogdown::hugo_build()
blogdown::serve_site()
blogdown::hugo_build()
blogdown::build_site()
rmarkdown::render_site(encoding = ‘UTF-8’)
rmarkdown::render_site(encoding = "UTF-8")
blogbb
